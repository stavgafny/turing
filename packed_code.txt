
const { app, BrowserWindow } = require('electron');

function createWindow() {
    const window = new BrowserWindow({
        width: 1920,
        height: 1080,
        frame: false
    });
    window.removeMenu();
    window.loadFile('index.html');
}

app.whenReady().then(() => {
    createWindow();
    app.on('activate', function () {
        if (BrowserWindow.getAllWindows().length === 0) createWindow()
    });
});

app.on('window-all-closed', function () {
    if (process.platform !== 'darwin') app.quit()
});

try {
    require('electron-reloader')(module)
} catch (_) { }
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <script src="./libraries/p5.min.js"></script>
    <script src="./libraries/assets.js"></script>
    <script src="./libraries/graphics.js"></script>
    <script src="./libraries/UI.js"></script>
    <script defer src="./libraries/engine.js"></script>
    <script defer src="./libraries/dom.js"></script>
    <script defer src="./main.js"></script>
</head>

<body>
    <!--
            <ul id="memory"></ul>
        -->
    <div id="memory">
        <span class="memory-container">
            <p id="memory_index" title="Index">~</p>
            <p id="memory_size" title="Size">~~~</p>
        </span>
        <ul id="cells"></ul>
    </div>
    <div id="builder">
        <div id="media">
            <!-- PLAY/PAUSE|RESET|UNDO|REDO|ENTITY NAME|CREATE NEW ENTITY -->
            <button id="play_pause" title="Play/Pause"></button>
            <button id="reset" title="Reset"></button>
            <svg id="undo" width="24" height="24" viewBox="0 0 24 24">
                <path
                    d="M13.427 3.021h-7.427v-3.021l-6 5.39 6 5.61v-3h7.427c3.071 0 5.561 2.356 5.561 5.427 0 3.071-2.489 5.573-5.561 5.573h-7.427v5h7.427c5.84 0 10.573-4.734 10.573-10.573s-4.733-10.406-10.573-10.406z" />
                <title>Undo</title>
            </svg>
            <svg id="redo" width="24" height="24" viewBox="0 0 24 24">
                <path
                    d="M10.573 3.021h7.427v-3.021l6 5.39-6 5.61v-3h-7.427c-3.071 0-5.561 2.356-5.561 5.427 0 3.071 2.489 5.573 5.561 5.573h7.427v5h-7.427c-5.84 0-10.573-4.734-10.573-10.573s4.733-10.406 10.573-10.406z" />
                <title>Redo</title>
            </svg>
            <form autocomplete="off" class="procedure">
                <input id="procedure_name" type="text" placeholder="Procedure" maxlength="10">
                <div style="display: flex;">
                    <input id="procedure_save" type="submit" value="Save">
                    <input id="procedure_delete" type="submit" value="Delete">
                </div>
            </form>
        </div>
        <div id="state">
            <!--
                    State:
                    [0] Input
                    [1] Ouput
                    [2] Direction
                -->
            <div>
                <p></p>
            </div>
            <div>
                <p></p>
            </div>
            <div>
                <p></p>
            </div>
        </div>
        <div id="entities">
        </div>
        <svg id="settings_button" viewBox="0 0 20 20">
            <path
                d="M10.032,8.367c-1.112,0-2.016,0.905-2.016,2.018c0,1.111,0.904,2.014,2.016,2.014c1.111,0,2.014-0.902,2.014-2.014C12.046,9.271,11.143,8.367,10.032,8.367z M10.032,11.336c-0.525,0-0.953-0.427-0.953-0.951c0-0.526,0.427-0.955,0.953-0.955c0.524,0,0.951,0.429,0.951,0.955C10.982,10.909,10.556,11.336,10.032,11.336z">
            </path>
            <path
                d="M17.279,8.257h-0.785c-0.107-0.322-0.237-0.635-0.391-0.938l0.555-0.556c0.208-0.208,0.208-0.544,0-0.751l-2.254-2.257c-0.199-0.2-0.552-0.2-0.752,0l-0.556,0.557c-0.304-0.153-0.617-0.284-0.939-0.392V3.135c0-0.294-0.236-0.532-0.531-0.532H8.435c-0.293,0-0.531,0.237-0.531,0.532v0.784C7.582,4.027,7.269,4.158,6.966,4.311L6.409,3.754c-0.1-0.1-0.234-0.155-0.376-0.155c-0.141,0-0.275,0.055-0.375,0.155L3.403,6.011c-0.208,0.207-0.208,0.543,0,0.751l0.556,0.556C3.804,7.622,3.673,7.935,3.567,8.257H2.782c-0.294,0-0.531,0.238-0.531,0.531v3.19c0,0.295,0.237,0.531,0.531,0.531h0.787c0.105,0.318,0.236,0.631,0.391,0.938l-0.556,0.559c-0.208,0.207-0.208,0.545,0,0.752l2.254,2.254c0.208,0.207,0.544,0.207,0.751,0l0.558-0.559c0.303,0.154,0.616,0.285,0.938,0.391v0.787c0,0.293,0.238,0.531,0.531,0.531h3.191c0.295,0,0.531-0.238,0.531-0.531v-0.787c0.322-0.105,0.636-0.236,0.938-0.391l0.56,0.559c0.208,0.205,0.546,0.207,0.752,0l2.252-2.254c0.208-0.207,0.208-0.545,0.002-0.752l-0.559-0.559c0.153-0.303,0.285-0.615,0.389-0.938h0.789c0.295,0,0.532-0.236,0.532-0.531v-3.19C17.812,8.495,17.574,8.257,17.279,8.257z M16.747,11.447h-0.653c-0.241,0-0.453,0.164-0.514,0.398c-0.129,0.496-0.329,0.977-0.594,1.426c-0.121,0.209-0.089,0.473,0.083,0.645l0.463,0.465l-1.502,1.504l-0.465-0.463c-0.174-0.174-0.438-0.207-0.646-0.082c-0.447,0.262-0.927,0.463-1.427,0.594c-0.234,0.061-0.397,0.271-0.397,0.514V17.1H8.967v-0.652c0-0.242-0.164-0.453-0.397-0.514c-0.5-0.131-0.98-0.332-1.428-0.594c-0.207-0.123-0.472-0.09-0.646,0.082l-0.463,0.463L4.53,14.381l0.461-0.463c0.169-0.172,0.204-0.434,0.083-0.643c-0.266-0.461-0.467-0.939-0.596-1.43c-0.06-0.234-0.272-0.398-0.514-0.398H3.313V9.319h0.652c0.241,0,0.454-0.162,0.514-0.397c0.131-0.498,0.33-0.979,0.595-1.43c0.122-0.208,0.088-0.473-0.083-0.645L4.53,6.386l1.503-1.504l0.46,0.462c0.173,0.172,0.437,0.204,0.646,0.083c0.45-0.265,0.931-0.464,1.433-0.597c0.233-0.062,0.396-0.274,0.396-0.514V3.667h2.128v0.649c0,0.24,0.161,0.452,0.396,0.514c0.502,0.133,0.982,0.333,1.433,0.597c0.211,0.12,0.475,0.089,0.646-0.083l0.459-0.462l1.504,1.504l-0.463,0.463c-0.17,0.171-0.202,0.438-0.081,0.646c0.263,0.448,0.463,0.928,0.594,1.427c0.061,0.235,0.272,0.397,0.514,0.397h0.651V11.447z">
            </path>
        </svg>
    </div>
    <div id="settings">
        <h1>Settings</h1>
        <h2>Engine</h2>
        <span>Tick rate</span>
        <input id="speed" type="range" min="10" max="1000" value="100">
        <span id="speed_tracker"></span>
    </div>
</body>

</html>
// Contains all mechine objects

//class Entity{}

class State {
    // Input is the key that comapers
    // Output is the value that changes the input to
    // Direction moves the stack pointer [ right=true | left=false ]

    static SPLITER = "|";

    static parse(string) {
        const [input, output, direction] = string.split(State.SPLITER);
        return new State({ input, output, direction });
    }

    static get direction() { return { right: "R", left: "L" }; }

    static get SPECIAL_KEYS() {
        return {
            all: "ʘ",
            null: "Ø",
            edge: "├",
            block: "§",
            print: "¥"
        }
    }

    static get DEFAULT() {
        return {
            input: State.SPECIAL_KEYS.all,
            output: State.SPECIAL_KEYS.all,
            direction: State.direction.right
        }
    }

    constructor({ input, output, direction }) {
        this.input = input;
        this.output = output;
        this.direction = direction;
    }

    get absoluteDirection() {
        if (this.direction === State.direction.right)
            return 1;
        else if (this.direction === State.direction.left)
            return -1;
        return 0;
    }

    get stringify() { return `${this.input}${State.SPLITER}${this.output}${State.SPLITER}${this.direction}`; }
}


class Connection {

    static parse(string) {
        let { path, state, next } = JSON.parse(string);
        path = JSON.parse(path);
        state = State.parse(state);
        next = getNextById(next);
        return { path, state, next };
    }

    constructor({ x, y }) {
        this.position = { x, y };
        this.state = new State(StateDOM.getState());
        this.path = [{ x, y }];
        this.next = null;
    }

    get stringify() {
        const path = JSON.stringify(this.path);
        const state = this.state.stringify;
        const next = this.next ? this.next.id : -1;
        return JSON.stringify({ path, state, next });
    }

    get connected() { return this.next !== null; }

    get last() { return this.path[this.path.length - 1]; }
}


class Queue {

    static parse(string) {
        let { position, id, connections } = JSON.parse(string);
        position = JSON.parse(position);
        return { position, id, connections };
    }

    static draw({ x, y }) {
        let intersects = false;
        const qs = graphics.sizes.queue;
        const cs = graphics.sizes.connection;
        for (let i = 0; i < queues.length && !intersects; i++) {
            intersects = graphics.overlaps({ x, y }, queues[i].position, qs + qs);
            for (let j = 0; j < queues[i].connections.length && !intersects; j++) {
                const position = queues[i].connections[j].position;
                intersects = graphics.overlaps({ x, y }, position, qs + cs);
            }
        }
        graphics.render.staticQueue({ x, y }, intersects);
        return intersects;
    }

    constructor({ x, y }, id) {
        this.position = { x, y };
        this.id = id;
        this.connections = [];
    }

    get stringify() {
        const position = JSON.stringify(this.position);
        const id = this.id;
        const connections = JSON.stringify(this.connections.map(connection => connection.stringify));
        return JSON.stringify({ position, id, connections });
    }

    get last() { return this.connections[this.connections.length - 1]; }

    get inBuild() { return this.last ? !this.last.connected : false; }

    build({ x, y }) {
        const newConnection = new Connection({ x, y });
        this.connections.push(newConnection);
        return newConnection;
    }

    next({ x, y }) {
        if (this.inBuild) {
            this.last.path.push({ x, y });
        }
    }

    end() {
        return this.last ? (!this.last.connected ? this.connections.pop() : null) : null;
    }

    draw(connectable, isQueue = true) {
        Mouse.deletable(this, graphics.sizes.queue);
        if (isQueue) {
            graphics.render.queue(this);
        } else {
            graphics.render.procedure(this);
        }
        if (connectable) {
            let con = Mouse.pullConnection(this.position, graphics.sizes.queue);
            graphics.render.queueConnectable(con);
            if (con.overlaps) {
                Mouse.onConnection = {
                    queue: this,
                    connection: { x: con.x, y: con.y }
                };
            }
        }
        // Returns if engine current is this queue or a connection of it
        return this === Engine.current || this.connections.indexOf(Engine.current) !== -1;
    }
}


class Procedure extends Queue {

    static identifier = "@";
    static ID = 0;

    static get(name) {
        // Gets a current procedure id, returns the instance of that procedure if exists
        if (!name || !isNaN(int(name)))
            return null;
        if (name.indexOf(Procedure.identifier) === -1)
            return null;
        return entities.procedures[name.split(Procedure.identifier)[0]];
    }

    static draw({ x, y }) {
        let intersects = false;
        const qs = graphics.sizes.queue;
        const cs = graphics.sizes.connection;
        for (let i = 0; i < queues.length && !intersects; i++) {
            intersects = graphics.overlaps({ x, y }, queues[i].position, qs + qs);
            for (let j = 0; j < queues[i].connections.length && !intersects; j++) {
                const position = queues[i].connections[j].position;
                intersects = graphics.overlaps({ x, y }, position, qs + cs);
            }
        }
        graphics.render.staticProcedure({ x, y }, intersects);
        return intersects;
    }

    constructor({ x, y }, id) {
        super({ x, y }, id + Procedure.identifier + Procedure.ID++);
        [this.name, this.number] = this.id.split(Procedure.identifier);
        this.instructions = null;
        this.instructionID = null;
        this.finished = null;
        this.progress = null;
        this.connectionStep = null;
        this.set(entities.procedures[id]);
    }

    get originID() { return this.name + Procedure.identifier + this.number; }

    get instruction() {
        const ids = this.instructions.map(o => o.id);
        return this.instructions[ids.indexOf(this.instructionID)];
    }

    set instruction(value) {
        this.instructionID = value;
    }

    reset() {
        this.instruction = this.instructions[0].id;
        this.finished = false;
        this.progress = 0;
        this.connectionStep = false;
    }

    end() {
        this.reset();
        this.finished = true;
    }

    set(instructions) {
        this.instructions = instructions;
        this.reset();
    }

    draw(connectable) {
        super.draw(connectable, false);
        // Returns if engine current is this procedure or a connection of it
        return this === Engine.current || this.connections.indexOf(Engine.current) !== -1;
    }
}


const getNewQueueId = () => {
    // If Q0-Q3 then new queue id is Q1 (if there are no jumps then id is queues length)
    const ids = [];
    ids.length = queues.length;
    queues.map(q => ids[q.id] = true);
    let id = null;
    for (let i = 0; i < ids.length && id === null; i++) {
        if (!ids[i]) {
            id = i;
        }
    }
    if (id === null)
        id = queues.length;
    return id;
}


const getNextById = id => {
    for (let i = 0; i < queues.length; i++) {
        if (queues[i].id === id) {
            return queues[i];
        }
    }
    return null;
}
// Handles all the dom elements and structures to the engine

class MemoryDOM {
    // Structures HTML memory element

    static #index = document.getElementById("memory_index");
    static #size = document.getElementById("memory_size");
    static #cells = document.getElementById("cells");
    static #pointerClass = "pointer";

    static get pointer() { return Math.floor(this.#index.innerText); }

    static get cell() { return this.#cells.children[this.pointer]; }

    static get cellInput() { return this.cell.innerText; }

    static set #pointer(value) {
        if (this.cell) {
            // Unset old cell
            this.cell.classList.remove(this.#pointerClass);
        }
        // Set as new current cell
        this.#index.innerText = value;
        this.cell.classList.add(this.#pointerClass);
        // Focus on current cell
        this.cell.scrollIntoView({
            behavior: "auto",
            block: "center",
            inline: "center"
        });
    }

    static #clear() {
        this.#cells.innerHTML = "";
    }

    static init(expression) {
        // Initializing the memory size, cells, pointer using the expression

        // Builds the memory using the build expression and the size on properties
        const { size, pointer, memory } = buildMemory(expression);
        this.#clear();
        for (let i = 0; i < size; i++) {
            const element = document.createElement("li");
            element.innerText = memory[i];
            this.#cells.appendChild(element);
        }
        this.#size.innerText = size;
        this.#pointer = pointer;
    }

    static setNext({ output, direction }) {
        // Sets new pointer if valid
        this.cell.innerText = output;
        const nextIndex = this.pointer + direction;
        if (nextIndex < this.#cells.children.length && nextIndex >= 0)
            this.#pointer = nextIndex;
    }

}


class StateDOM {
    // Structures HTML state element

    static #INPUT = 0; static #OUTPUT = 1; static #DIRECTION = 2;
    static #tester = /^[A-Za-z0-9]*$/;
    static #dom = document.getElementById("state");

    // Setting state elements
    static input = this.#dom.children[this.#INPUT];
    static output = this.#dom.children[this.#OUTPUT];
    static direction = this.#dom.children[this.#DIRECTION];
    static setter = "set-state";

    static get onEdit() {
        return this.input.classList.contains(this.setter) || this.output.classList.contains(this.setter);
    }

    static clear() {
        this.input.classList.remove(this.setter);
        this.output.classList.remove(this.setter);
    }

    static handleKeyInput(key) {
        // Changing state(either input or output) keys if they are in "set_state"
        let element = this.input.classList.contains(this.setter) ? this.input : null;
        if (!element) element = this.output.classList.contains(this.setter) ? this.output : null;
        if (element) {
            const specialKey = State.SPECIAL_KEYS[STATE_KEYS[key]];
            if (specialKey) {
                element.children[0].innerText = specialKey;
            } else if (this.#tester.test(char(key))) {
                element.children[0].innerText = char(key);
            } else {
                return false;
            }
            element.classList.remove(this.setter);
            return true;
        }
        return false;
    }

    static getState() {
        return {
            input: this.input.innerText,
            output: this.output.innerText,
            direction: this.direction.innerText
        };
    }
}


class MediaDOM {
    // All media control

    static #undoRedoAvailable = "available";
    static #undoRedoActivation = "activated";
    static #undoRedoActivationDelay = 1;
    static #tester = /^[A-Za-z0-9]*$/;

    static playPause = document.getElementById("play_pause");
    static reset = document.getElementById("reset");
    static undo = document.getElementById("undo");
    static redo = document.getElementById("redo");
    static procedureName = document.getElementById("procedure_name");
    static procedureSave = document.getElementById("procedure_save");
    static procedureDelete = document.getElementById("procedure_delete");

    static #handleUndoRedo = (dom, method) => {
        // Gets DOM element and undo/redo method
        // Effacts DOM element if there was an undo/redo method then
        if (!method)
            return false;
        dom.classList.add(this.#undoRedoActivation);
        setTimeout(() => dom.classList.remove(this.#undoRedoActivation), this.#undoRedoActivationDelay);
        this.refreshUndoRedo();
        return true;
    }

    static refreshUndoRedo() {
        if (Memo.hasUndo())
            this.undo.classList.add(this.#undoRedoAvailable);
        else
            this.undo.classList.remove(this.#undoRedoAvailable);
        if (Memo.hasRedo())
            this.redo.classList.add(this.#undoRedoAvailable);
        else
            this.redo.classList.remove(this.#undoRedoAvailable);
    }

    static callUndo() {
        if (this.#handleUndoRedo(this.undo, Memo.undo()))
            Engine.stop();
    }

    static callRedo() {
        if (this.#handleUndoRedo(this.redo, Memo.redo()))
            Engine.stop();
    }

    static createProcedure() {
        // Creates a new produce from all the current queues
        const produceName = this.procedureName.value;
        if (!(produceName.length > 0) || !isNaN(int(produceName)) || !this.#tester.test(produceName) || entities.procedures[produceName] || !(queues.length > 0)) {
            // there is all ready a procedure entity with that name / procedure has no content / procedure name isn't valid
            return false;
        }
        entities.createProcedure(produceName);
        EntitiesDOM.createEntity(produceName);
    }

    static deleteProcedure() {
        // Deletes the procedure that is the current entity(if not default[queue])
        if (entities.name !== entities.default) {
            entities.procedures[entities.name] = null;
            EntitiesDOM.deleteEntity(entities.name);
        }
    }
}


class EntitiesDOM {

    static #dom = document.getElementById("entities");

    static createEntity(name) {
        const entity = document.createElement("button");
        entity.id = entities.identifier + name;
        entity.innerText = name;
        entity.onclick = function () { entities.current = this.id; };
        this.#dom.appendChild(entity);
        return entity.id;
    }

    static deleteEntity(name) {
        const entity = document.getElementById(entities.identifier + name);
        console.log(entity);
        this.#dom.removeChild(entity);
    }
}


class SettingsDOM {
    // Settings window

    static #display = "display";

    static displayButton = document.getElementById('settings_button');
    static settingsWindow = document.getElementById("settings");
    static speedRange = document.getElementById("speed");
    static speedTracker = document.getElementById("speed_tracker");

    static get displayed() { return this.settingsWindow.classList.contains(this.#display); }

    static #windowDisplayMode(mode) {
        const children = this.settingsWindow.children;
        for (let i = 0; i < children.length; i++) {
            const element = children[i];
            element.disabled = !mode;
        }
        mode = mode ? "add" : "remove";
        this.settingsWindow.classList[mode](this.#display);
    }

    static escape() {
        this.#windowDisplayMode(false);
    }

    static displaySettings() {
        this.#windowDisplayMode(true);
    }

    static handleSpeedChange() {
        properties.speed = this.speedRange.value;
        this.speedTracker.innerText = properties.speed + "ms";
    }

}

// Binds elements
StateDOM.input.children[0].innerText = State.SPECIAL_KEYS.all;
StateDOM.output.children[0].innerText = State.SPECIAL_KEYS.all;
StateDOM.direction.children[0].innerText = State.direction.right;
StateDOM.input.onclick = function () { this.classList.add(StateDOM.setter); StateDOM.output.classList.remove(StateDOM.setter); }
StateDOM.output.onclick = function () { this.classList.add(StateDOM.setter); StateDOM.input.classList.remove(StateDOM.setter); }
StateDOM.direction.onclick = function () { this.children[0].innerText = (this.children[0].innerText === 'R') ? 'L' : 'R'; }
MediaDOM.playPause.onclick = function () { Engine.running ? Engine.stop() : Engine.run(); this.blur(); }
MediaDOM.reset.onclick = function () { Engine.reset(); this.blur(); queues.map(q => q instanceof Procedure ? q.reset() : null) }
MediaDOM.undo.onclick = function () { MediaDOM.callUndo(); }
MediaDOM.redo.onclick = function () { MediaDOM.callRedo(); }
MediaDOM.procedureSave.onclick = function() { MediaDOM.createProcedure(); }
MediaDOM.procedureDelete.onclick = function() { MediaDOM.deleteProcedure(); }
SettingsDOM.displayButton.onclick = function () { SettingsDOM.displaySettings(); }
SettingsDOM.speedRange.oninput = function () { SettingsDOM.handleSpeedChange(); }
// Responsible for how the mechine runs

class Engine {
    // Handles the mechine and connects with DOM elements

    static #stack = [];
    static #runner = null;
    static current = null;

    static print = null;

    static get running() { return this.#runner !== null; }

    static get stackCopy() {
        return Object.assign([], this.#stack);
    }

    static #getMatchingInput(connections) {
        // Gets list of connections
        // Returns the one that matches the current cell input and returns it if one exsists

        // All connections inputs
        const inputs = connections.map(c => c.state.input);
        const input = MemoryDOM.cellInput;
        // Tries first to get a specific connection input
        // If not found, falls back to "all" connection
        let index = inputs.indexOf(input);
        if (index === -1)
            index = inputs.indexOf(State.SPECIAL_KEYS.all)
        return connections[index];
    }

    static #applyStateOutput(state) {
        // Apllies the state output to the memory
        // No output change if connection output is "all" special key
        const output = state.output === State.SPECIAL_KEYS.all ?
            MemoryDOM.cellInput : state.output;
        const direction = state.absoluteDirection;
        MemoryDOM.setNext({ output, direction });
    }

    static #nextConnection() {
        // Next path from connections

        // Gets all filtered connections from in build ones(not connected)
        const connections = this.current.connections.filter(c => c.connected);
        const match = this.#getMatchingInput(connections);
        // If there is no next path(there is no connection found)
        if (!match)
            return Engine.stop();

        // Found a matching connection that input matches current cell input
        // No output change if connection output is "all" special key
        this.#applyStateOutput(match.state);
        this.current = match;
    }

    static #nextInstruction() {
        // Next path from instruction
        
        // Handles procedure connection step
        this.current.connectionStep = !this.current.connectionStep;
        if (this.current.connectionStep) return;

        // Check if current instruction has instructions then it's a procedure(nested procedure)
        const instructions = Procedure.get(this.current.instruction.id);
        if (instructions) {
            this.#stack.push({id : this.current.id, instructionID : this.current.instruction.id});
            this.current.id = this.current.instruction.id;
            this.current.set(instructions);
            this.current.reset();
            // Next instruction on the nested procedure
            return this.#nextInstruction();
        }

        let match = this.#getMatchingInput(this.current.instruction.connections);
        while (!match && this.#stack.length > 0) {
            const {id, instructionID} = this.#stack.pop();
            const instructions = Procedure.get(id);
            this.current.id = id;
            this.current.set(instructions);
            this.current.instruction = instructionID;
            match = this.#getMatchingInput(this.current.instruction.connections);
        }
        if (match) {
            this.#applyStateOutput(match.state);
            this.current.instruction = match.next;
        } else {
            this.current.end();
        }
    }

    static #tick() {
        // Next mechine step
        if (!this.current) return;

        // If currently on connection tick to the connected side
        if (this.current instanceof Connection) {
            this.current = this.current.next;
            if (this.current instanceof Procedure) {
                this.current.reset();
            }
            return;
        }

        // Checks if current is a valid queue / Procedure[sub class of queue]
        if (!(this.current instanceof Queue)) return;

        // If current is a procedure
        if (this.current instanceof Procedure) {
            // If procedure is finished, get the next path from the procedure connections(not from procedure instruction)
            if (this.current.finished) {
                return this.#nextConnection();
            }
            this.#nextInstruction();
        } else {
            // Then it's a queue
            this.#nextConnection();
        }
    }

    static setCurrent(current) {
        /*
        Sets new engine current
        If changed current is a procedure reset it
        If stack isn't empty, reset it and set changed current to it's origin
        */
        if (this.current instanceof Procedure) {
            this.current.reset();
            if (this.#stack.length > 0) {
                const {id, instructionID} = this.#stack[0];
                const instructions = Procedure.get(id);
                this.current.id = id;
                this.current.set(instructions);
                this.current.instruction = instructionID;
                this.#stack = [];
            }
        }
        this.current = current;
    }

    static run() {
        // Starts runner if runner isn't running
        if (this.running) return;
        this.#runner = Date.now();
        MediaDOM.playPause.classList.add("pause");
    }

    static stop() {
        // Clears runner and set play/pause button state
        this.#runner = null;
        MediaDOM.playPause.classList.remove("pause");
    }

    static reset() {
        this.stop();
        MemoryDOM.init(properties.memory);
        this.setCurrent(queues[0]);
    }

    static update() {
        let deltatime = Date.now() - this.#runner;
        if (deltatime >= properties.speed) {
            this.#runner += deltatime;
            this.#tick();
        }
        if (this.current instanceof Procedure && this.running) {
            let inc = 0;
            if (deltatime > properties.speed / 2)
                inc = (deltatime / properties.speed * 2) * 90;
            this.current.progress = this.current.finished ? 0 : inc;
            if (deltatime >= properties.speed || !this.current.connectionStep) {
                this.current.progress = 0;
            }
        }
    }
}

const buildMemory = expression => {
    /*
        Converts string expression that represents the memory
        Returns the memory size, build order, pointer using that expression context
        EXPRESSION "size@|key : value|key ! value?defaultKey$pointer"
        TYPES [":", "!"] = [absoulte value, jumping value]
        >>> JUMPS OVERRIDE ABSOULTE VALUE <<<
    */
    const ABSOULTE = ":";
    const JUMPS = "!";

    // Validates expression
    // Checks must values: size, defaultKey, pointer are invalid (build is an option not a must like the others)
    const errors = [];
    if (typeof expression !== "string")
        errors.push("\t* Expression must be a string");
    if (expression.indexOf("@") === -1)
        errors.push("\t* Expression must have memory size");
    if (expression.indexOf("?") === -1)
        errors.push("\t* Expression must have a default key");
    if (expression.indexOf("$") === -1)
        errors.push("\t* Expression must define a pointer");

    // If there is at least one error
    if (errors.length > 0) {
        throw new Error("\n" + errors.join("\n"));
    }
    try {
        // Sets size, defaultKey to fill the memory, pointer, build order
        const size = Math.floor(expression.split("@")[0]);
        const [defaultKey, pointer] = expression.split("?")[1].split("$").reduce((a, b) => [a, Math.floor(b)]);
        const build = expression.split("@")[1].split("?")[0].split("|").slice(1, -1);
        // Sets the memory array with default key and seals it so there wont be any leaks
        const output = new Array(size).fill(defaultKey);
        Object.seal(output);
        const jumps = [];
        let index = 0;

        const getLength = value => {
            // Length is the number of times key is called on cells starting from index
            let length = Math.floor(value);
            if (value.endsWith("%")) {
                // Get length in precentage based of total size left (rounds up)
                const precentage = value.slice(0, -1) * 0.01;
                length = Math.round(precentage * (size - index));
            }
            return length;
        }

        const getIndex = value => {
            let _index = Math.floor(value);
            if (value.endsWith("%")) {
                // Get total index precentage from the total size 
                const precentage = value.slice(0, -1) * 0.01;
                _index = Math.floor(precentage * size);
            }
            return _index;
        }

        for (pair of build) {
            // Each pair is a build order that has a key and a value
            // Tries to set cells to key * value from index, Ignores pair if faills
            try {
                if (pair.includes(ABSOULTE)) {
                    // Key : value -> ":" total length value (either precentage or absolute value)
                    const [key, value] = pair.split(":");
                    const length = getLength(value);
                    // If length=-1 run on all left cells except for one
                    if (length > 0) {
                        output.fill(key, index, index + length);
                        index += length;
                    } else if (length <= 0) {
                        output.fill(key, index, length);
                        index = size + length;
                    }
                } else if (pair.includes(JUMPS)) {
                    // Key ! value -> "!" iterates on each value number to put key(jumping)
                    const [key, value] = pair.split("!");
                    const length = getLength(value);
                    if (length > 0) {
                        jumps.push({ key, length, index: index });
                    }
                } else {
                    // If pair is only a number then set index to it, if +/- included then inc/sub to index
                    const _index = getIndex(pair);
                    if (_index !== NaN) {
                        if (pair.includes("+") || pair.includes("-"))
                            index += _index;
                        else
                            index = _index;
                    }
                }
                for (const { key, length, index } of jumps) {
                    for (let i = index + length - 1; i < size; i += length) {
                        output[i] = key;
                    }
                }
            } catch { }
        }
        return { size, pointer, memory: output };
    } catch (e) {
        throw new Error("Invalid expression\n");
    }
}


/*
class IO {

    static save() {
        const procedures = entities.values;
        console.log(procedures);
        const stringified = { properties, queues }
        stringified.queues = JSON.stringify(stringified.queues.map(queue => queue.stringify));
        return JSON.stringify(stringified);
    }

    static load(data) {
        const queues = JSON.parse(data.queues).map(queueData => Queue.parse(queueData));
        queues.map(queue => {
            queue.connections = JSON.parse(queue.connections).map(connection => Connection.parse(connection));
        });
        return { queues };
    }
}

*/
// Represents the program graphically. Draws on the canvas with defined sizes and colors

const graphics = (function () {

    const colors = {
        background: "#5a5d60",
        grid: "#00000044",
        queue: "#ddd",
        connection: "#333",
        connectionHover: "#abc",
        arrow: "#000",
        buildArrow: "#aaa",
        intersects: "#faa",
        notIntersects: "#ada",
        delete: "#f76",
        procedureAlive : "#9da",
        procedureFinished : "#50000099",
        procedureConnectionStep : "#bdf",
        get current() { return Engine.running ? "#44e" : "#124"; }
    };

    const sizes = {
        queue: 80,
        connection: 22,
        connecting: 10,
        arrowStroke: 3,
        arrowTriangle: 8,
        arrowPointer: 24,
        current: 6
    };

    const drawConnections = queue => {
        // Draws all connections of a given queue
        // Checks each connection, color based of deleteable (mouse hovers and delete key is pressed)
        queue.connections.map(con => {
            drawConnectionPath(con);
            Mouse.deletable(con, sizes.connection);
            const { x, y } = con.position;
            push();
            noStroke();
            fill(Mouse.onDelete === con ? colors.delete :
                (con === Engine.current) ? colors.current : colors.connection);
            ellipse(x, y, sizes.connection * 2);
            fill(255);
            textSize(sizes.connection * .65);
            text(con.state.stringify, x, y);
            pop();
        });
    };

    const drawConnectionPath = build => {
        // Draws connection path
        const { x, y } = build.last;
        // If not connected(in build) only sub length by one because point 2 is mouse position
        const length = build.path.length - (1 * build.connected ? 2 : 1);
        let color = (build === Engine.current) ? colors.current : colors.arrow;
        push();
        strokeWeight(sizes.arrowStroke);
        stroke(color);
        for (let i = 0; i < length; i++) {
            line(
                build.path[i].x,
                build.path[i].y,
                build.path[i + 1].x,
                build.path[i + 1].y
            );
        }
        // If not connected(in build) last path is last point and mouse position
        // Else last path = two last points
        let p1 = { x, y };
        let p2 = Mouse.position;
        if (build.connected) {
            p1 = build.path[build.path.length - 2];
            p2 = { x, y };
        }
        if (!build.connected) {
            stroke(colors.buildArrow);
            fill(colors.buildArrow);
        } else {
            stroke(color);
            fill(color);
        }
        drawConnectionArrow(p1, p2);
        pop();
    };

    const drawConnectionArrow = (p1, p2) => {
        // Draws last path and arrow, color is based of connection in build
        if (dist(p1.x, p1.y, p2.x, p2.y) <= 0) return;
        const angle = exports.getAngle(p1, p2);
        const v = sizes.arrowTriangle;
        const vp = sizes.arrowPointer;
        const sub = {
            x: vp * angle.x,
            y: vp * angle.y
        };
        push();
        // Last path
        line(p1.x, p1.y, p2.x + sub.x, p2.y + sub.y);
        // Triangle
        translate(p2.x + sub.x, p2.y + sub.y);
        rotate(angle.value);
        noStroke();
        triangle(0, v, 0, -v, -vp, 0);
        pop();
    };

    const exports = {
        // All public variables and function on graphics (vector calculations, rendering)

        sizes: sizes,
        // Checks if two points are overlapping each other on a given sum radius
        // 2 queues -> r = queue_radius * 2, queue and connection -> r = queue_radius + connection_radius
        overlaps: (a, b, r) => (a.x - b.x) ** 2 + (a.y - b.y) ** 2 <= r ** 2,

        // Gets two points and returns angle between them + x/y vector increments of angle
        getAngle: (p1, p2) => {
            const angle = createVector(p1.x - p2.x, p1.y - p2.y).heading();
            return {
                value: angle,
                x: cos(angle),
                y: sin(angle)
            };
        },

        render: {
            // Render object returns functions that affect the canvas

            background: fixedGrid => {
                // Draws background and grid if enabled
                push();
                background(colors.background);
                pop();
                if (!fixedGrid) return;
                push();
                noStroke();
                fill(colors.grid);
                for (let y = 1; y < height / GRID.size; y++) {
                    for (let x = 1; x < width / GRID.size; x++) {
                        ellipse(x * GRID.size, y * GRID.size, GRID.dotSize);
                    }
                }
                pop();
            },

            staticQueue: ({ x, y }, intersects) => {
                // Draw queue minimal
                push();
                noStroke();
                fill(intersects ? colors.intersects : colors.notIntersects);
                ellipse(x, y, sizes.queue * 2);
                pop();
            },

            staticProcedure: ({ x, y }, intersects) => {
                // Draw procedure
                const value = Math.sqrt(2) * sizes.queue;
                push();
                translate(x, y);
                noStroke();
                fill(intersects ? colors.intersects : colors.notIntersects);
                ellipse(0, 0, sizes.queue * 2);
                stroke(0);
                noFill();
                ellipse(0, 0, value);
                rect(0, 0, value, value, 10);
                pop();
            },

            queue: queue => {
                // Draw queue object
                const { x, y } = queue.position;
                push();
                // Queue
                translate(x, y);
                if (queue === Engine.current) {
                    strokeWeight(sizes.current);
                    stroke(colors.current);
                } else {
                    noStroke();
                }
                fill(Mouse.onDelete === queue ? colors.delete : colors.queue);
                ellipse(0, 0, sizes.queue * 2);
                noStroke();
                // Text
                fill(0);
                textSize(sizes.queue * .75);
                text('q', 0, 0);
                // Number
                fill(80);
                textSize(sizes.queue / 3);
                text(queue.id, textWidth('q') + textWidth(queue.id) / 2, sizes.queue / 4);
                pop();
                // All queue connections
                drawConnections(queue);
            },

            procedure: procedure => {
                const { x, y } = procedure.position;
                const value = Math.sqrt(2) * sizes.queue;
                let nested = [];
                if (procedure === Engine.current) {
                    nested = Engine.stackCopy;
                }
                push();
                // procedure
                translate(x, y);
                fill(Mouse.onDelete === procedure ? colors.delete : colors.queue);
                if (procedure === Engine.current) {
                    strokeWeight(sizes.current);
                    stroke(colors.current);
                } else {
                    stroke(0);
                }
                ellipse(0, 0, sizes.queue * 2);
                strokeWeight(sizes.current / 3);
                stroke(0);
                push();
                rotate(procedure.progress);
                fill(procedure.finished ? colors.procedureFinished : procedure.connectionStep ? colors.procedureConnectionStep : colors.procedureAlive);
              
                rect(0, 0, value, value, 10);
                pop();
                ellipse(0, 0, value);
                noStroke();
                fill(0);
                textSize(sizes.queue / Math.sqrt(procedure.name.length * 2));
                text(procedure.name, 0, 0);
                textSize(30);
                let m = "";
                for (let i = 0; i < nested.length; i++) m += ".";
                text(m, 0, 15);
                pop();
                // All procedure connections
                drawConnections(procedure);
            },

            queueConnectable: ({ x, y, overlaps }) => {
                // Gets connection position and if overlapping
                // Draws connection with size and color based of overlaps
                let radius = buildConnection ? sizes.connecting : sizes.connection;
                push();
                noStroke();
                fill(overlaps ? colors.connectionHover : colors.connection);
                ellipse(x, y, radius * 2);
                pop();
            }
        }
    };
    return exports;
})();
// Responsible to all user interactions with the program
const SHIFT_KEY = 16;
const CNTRL_KEY = 17;
const ALT_KEY = 18;
const ESCAPE_KEY = 27;
const SPACE_KEY = 32;
const X_KEY = 88;
const Z_KEY = 90;
const TILDE_KEY = 192;
const MOUSE_CLICK = { left: 0, middle: 1, right: 2 };


const KEYBINDS = {
    gridToggle: MOUSE_CLICK.middle,
    queueBuild: SHIFT_KEY,
    connectionBuild: CNTRL_KEY,
    delete: ALT_KEY,
    undo: Z_KEY,
    redo: X_KEY,
    playPause: SPACE_KEY
}

const STATE_KEYS = {};
STATE_KEYS[ESCAPE_KEY] = "all";
STATE_KEYS[CNTRL_KEY] = "null";
STATE_KEYS[SHIFT_KEY] = "print";
STATE_KEYS[ALT_KEY] = "block";
STATE_KEYS[TILDE_KEY] = "edge";

const GRID = {
    size: 20,
    dotSize: 4
};

let buildConnection = null;

class Mouse {
    // Responsible to all mouse releated things

    static fixed = false; // Grid

    static fitQueue = false; // Can a queue spawn

    static onConnection = null; // Hovered connection

    static onDelete = null; // Hovered object on delete key

    static update() {
        // Updates mouse current state
        this.fitQueue = false;
        this.onConnection = null;
        this.onDelete = null;
    }

    static deletable(obj, size) {
        // Checks if given object is hovered using given size
        // If hovered and delete key is pressed then store object
        if (keyIsDown(KEYBINDS.delete) && !this.onDelete) {
            if (graphics.overlaps(obj.position, this.position, size)) {
                this.onDelete = obj;
            }
        }
    }

    static get position() {
        // Returns mouse absolute/fixed position based on fixed(true/false)
        if (this.fixed)
            return {
                x: Math.floor(mouseX / GRID.size) * GRID.size,
                y: Math.floor(mouseY / GRID.size) * GRID.size
            };
        return { x: mouseX, y: mouseY };
    }

    static pullConnection({ x, y }, r) {
        // Gets position and radius
        // Returns the closest position to mouse in radius
        const m = this.position;
        const v = { x: (m.x - x), y: (m.y - y) };
        v.v = sqrt(v.x ** 2 + v.y ** 2);
        const output = {
            x: x + (v.x / v.v * r),
            y: y + (v.y / v.v * r)
        };
        const radius = buildConnection ? graphics.sizes.connecting : graphics.sizes.connection;
        output.overlaps = graphics.overlaps(m, output, radius);
        return output;
    }

}


class Memo {
    // Responsible to all temporary changes made on the mechine
    // Operations -> spawn/delete a queue/connection, undo, redo
    // Each push to #undo/#redo is a list that contains all changes.

    static #CREATE = true; static #DELETE = false; // Type

    static #undo = [];
    static #redo = [];

    static #FORMAT = (list, obj, type) => ({ list, obj, type });

    static hasUndo() { return this.#undo.length > 0; }
    static hasRedo() { return this.#redo.length > 0; }

    static #handleSave = operator => {
        // If operator is undo then create last change else if it's redo then delete last change
        // Save last change to the oppsite of operator, example: popped from undo, saved in redo 
        const save = operator.pop();
        // If there is no undo/redo left return false
        if (!save) return false;
        save.map(({ list, obj, type }) => {
            if (operator === this.#undo ? type === this.#CREATE : type === this.#DELETE) {
                let index = list.indexOf(obj);
                if (index !== -1) {
                    list.splice(index, 1);
                }
            } else {
                list.push(obj);
            }
        });
        // Oppsite of operator
        (operator === this.#undo ? this.#redo : this.#undo).push(save);
        return true;
    }

    static create(list, obj) {
        // Spawns object(queue/connection) saves on #undo(type=created), resets redo
        list.push(obj);
        this.#undo.push([this.#FORMAT(list, obj, this.#CREATE)]);
        this.#redo = [];
        MediaDOM.refreshUndoRedo();
        Engine.stop();
    }

    static delete(obj) {
        /*
        Deletes object(queue/connection), saves on #undo(type=deleted), resets redo
        Removes object from queues if found, else object is a connection
        If object is a connection. finds connection in one of the queues and removes it
        If object is a queue, removes all connections connected to that queue
        Pushes to #undo a list{save} of all changes(in the case of connections connected to deleted queue)
        */
        const save = [];
        let index = queues.indexOf(obj);
        if (index !== -1) {
            queues.splice(index, 1);
            save.push(this.#FORMAT(queues, obj, this.#DELETE));

            // Check if other queues were connected to deleted queue
            queues.map(queue => {
                const filteredConnections = queue.connections.filter(connection => {
                    if (connection.next === obj) {
                        save.push(this.#FORMAT(queue.connections, connection, this.#DELETE));
                    } else {
                        return connection;
                    }
                });
                // Filters queue connections by removing all connections connected to deleted queue
                queue.connections.length = 0;
                queue.connections.push(...filteredConnections);
            });

        } else {
            // If object not found in queues then it is a connection
            // Searches for the connection in all the queues and stops once it finds it
            let queue;
            for (let i = 0; i < queues.length && index === -1; i++) {
                queue = queues[i];
                index = queue.connections.indexOf(obj);
            }
            if (index !== -1) {
                queue.connections.splice(index, 1);
                save.push(this.#FORMAT(queue.connections, obj, this.#DELETE));
            }
        }

        this.#undo.push(save);
        this.#redo = [];
        MediaDOM.refreshUndoRedo();
        Engine.stop();
    }

    static undo() {
        return this.#handleSave(this.#undo);
    }

    static redo() {
        return this.#handleSave(this.#redo);
    }
}



function windowResized() {
    resizeCanvas(window.innerWidth, window.innerHeight * CANVAS_HEIGHT_WRAPPER);
}

function mousePressed(e) {
    StateDOM.clear();

    if (e.button === KEYBINDS.gridToggle) { return Mouse.fixed = !Mouse.fixed; }

    if (e.button === MOUSE_CLICK.right) return;

    if (Mouse.onDelete)
        // Deletes object[queue/connection]
        return Memo.delete(Mouse.onDelete);

    if (Mouse.fitQueue) {
        // Creates a new queue/procedure
        const id = (entities.name === entities.default) ? getNewQueueId() : entities.name;
        return Memo.create(queues, new entities.current(Mouse.position, id));
    }

    if (buildConnection) {
        if (Mouse.onConnection) {
            /*
            If connection in build and pressed on another connection then it's the connected side 
            Makes connection arrow to connect properly by aiming to the connected
            queue center and making a gap 1.5 times the size of the arrow.
            Connects connection to queue and setting the path to it
            */
            const { queue, connection } = Mouse.onConnection;
            // Get angle to the center of the queue(aim arrow)
            const angle = graphics.getAngle(connection, queue.position);
            const connectionShorted = {
                x: connection.x + graphics.sizes.connection * angle.x * 1.5,
                y: connection.y + graphics.sizes.connection * angle.y * 1.5,
            };
            buildConnection.queue.next(connectionShorted);
            buildConnection.queue.next(connection);
            buildConnection.connection.next = queue;
            // Re-adding object again using Memo to save changes(undo/redo)
            buildConnection.queue.connections.pop();
            Memo.create(buildConnection.queue.connections, buildConnection.connection)
            buildConnection = null;
            return;
        }
        // If on connection on build but not on connected then add connection next path
        buildConnection.queue.next(Mouse.position);
        return;
    }

    if (keyIsDown(KEYBINDS.connectionBuild) && Mouse.onConnection) {
        // If connection key is pressed and mouse hovers a connection and not buildConnection(checked previously)
        // Build a connection and set to in build
        const { queue, connection } = Mouse.onConnection;
        buildConnection = {
            queue: queue,
            connection: queue.build(connection)
        };
        return;
    }

}

function keyPressed(e) {
    if (e.keyCode === ALT_KEY) e.preventDefault();
    if (e.keyCode === ESCAPE_KEY && !StateDOM.onEdit) SettingsDOM.displayed ? SettingsDOM.escape() : SettingsDOM.displaySettings();

    if (StateDOM.handleKeyInput(e.keyCode)) return;
    if (document.activeElement === MediaDOM.procedureName) return;

    if (e.keyCode === KEYBINDS.playPause) return MediaDOM.playPause.click();
    if (e.keyCode === KEYBINDS.undo) return MediaDOM.callUndo();
    if (e.keyCode === KEYBINDS.redo) return MediaDOM.callRedo();
}

function keyReleased(e) {
    if (e.keyCode === KEYBINDS.connectionBuild && buildConnection) {
        // If connection key released and connection in build, clear buildConnection either way(connected or not)
        if (!buildConnection.connection.connected)
            // If connection isn't connected(still in build) remove it
            buildConnection.queue.connections.pop();
        buildConnection = null;
    }
}

document.addEventListener("contextmenu", event => event.preventDefault());
// Main script, everything is running from here

const CANVAS_HEIGHT_WRAPPER = .88;
const queues = [];
const entities = {
    get identifier() { return "."; },
    get default() { return "queue"; },
    get name() { return window.location.hash.slice(2); /* removes has and identifier at the begining([#.]) */ },
    get current() { return (this.name === this.default) ? Queue : Procedure; },
    set current(value) { window.location.hash = value; },
    procedures: {},
    createProcedure(name) {
        const procedureInstructions = [];
        queues.map(queue => {
            const id = queue instanceof Procedure ? queue.originID : queue.id;
            procedureInstructions.push({
                id,
                connections : queue.connections.map(connection => ({ state: connection.state, next: connection.next.id }))
            });
        });
        this.procedures[name] = procedureInstructions;
    }
};

const properties = {
    speed: 200,
    memory: `200@|${State.SPECIAL_KEYS.edge}:1|0:10|R:1|1:1|?1$1`
};

function setup() {
    createCanvas(window.innerWidth, window.innerHeight * CANVAS_HEIGHT_WRAPPER);
    cursor(CROSS);
    textAlign(CENTER, CENTER);
    textFont("helivna");
    strokeCap(SQUARE);
    rectMode(CENTER);
    angleMode(DEGREES);
    Engine.reset();
    SettingsDOM.speedRange.value = properties.speed;
    SettingsDOM.handleSpeedChange();
    const defaultEntity = EntitiesDOM.createEntity(entities.default);
    entities.current = "";
    entities.current = defaultEntity;
    //debug().loop();
}

function draw() {
    clear();
    cursor(CROSS);
    Mouse.update();
    graphics.render.background(Mouse.fixed);
    // Checks if one of the queues is/has the engine current
    const hasCurrent = queues.filter(queue => queue.draw(keyIsDown(KEYBINDS.connectionBuild))).length === 1;

    if (keyIsDown(KEYBINDS.queueBuild)) {
        // Queue.draw returns if queue is overlapping
        Mouse.fitQueue = !entities.current.draw(Mouse.position);
    }
    // If there is currently no engine current -> set a new one
    if (!hasCurrent)
        Engine.setCurrent(queues[0]);
    if (Engine.running)
        Engine.update();
}

function debug() {

    return {
        loop : function() {
            Memo.create(queues, new Queue({ x: 200, y: 400 }, queues.length));
            queues[0].build({ x: 280, y: 400 });
            queues[0].next({ x: 520, y: 400 });
            queues[0].connections[0].next = queues[0];
            let c = queues[0].connections.pop();
            Memo.create(queues[0].connections, c);
            MediaDOM.procedureName.value = "Debug";
            MediaDOM.createProcedure(event);
            queues.length = 0;
            Memo.create(queues, new Procedure({ x: 200, y: 400 }, "Debug"));
            MediaDOM.procedureName.value = "Debugx";
            MediaDOM.createProcedure(event);
            queues.length = 0;
            Memo.create(queues, new Procedure({ x: 200, y: 400 }, "Debugx"));
            MediaDOM.procedureName.value = "Debugxs";
            MediaDOM.createProcedure(event);
            queues.length = 0;
            Memo.create(queues, new Procedure({ x: 200, y: 400 }, "Debugxs"));
            MediaDOM.procedureName.value = "Debugxss";
            MediaDOM.createProcedure(event);
            queues.length = 0;
            Memo.create(queues, new Procedure({ x: 200, y: 400 }, "Debugxss"));
            MediaDOM.procedureName.value = "";
        },
        nested : function() {
            Memo.create(queues, new Queue({ x: 200, y: 400 }, queues.length));
            Memo.create(queues, new Queue({ x: 600, y: 400 }, queues.length));
            Memo.create(queues, new Queue({ x: 900, y: 400 }, queues.length));
            queues[0].build({ x: 280, y: 400 });
            queues[0].next({ x: 520, y: 400 });
            queues[0].connections[0].next = queues[1];
            let c = queues[0].connections.pop();
            c.state.output = "M";
            Memo.create(queues[0].connections, c);
            queues[1].build({ x: 680, y: 400 });
            queues[1].next({ x: 820, y: 400 });
            queues[1].connections[0].next = queues[2];
            c = queues[1].connections.pop();
            c.state.output = "D";
            Memo.create(queues[1].connections, c);
            MediaDOM.procedureName.value = "Debug";
            MediaDOM.createProcedure(event);
            queues.length = 0;
            Memo.create(queues, new Queue({ x: 200, y: 100 }, queues.length));
            Memo.create(queues, new Procedure({ x: 200, y: 400 }, "Debug"));
            Memo.create(queues, new Procedure({ x: 700, y: 400 }, "Debug"));
            c = new Connection({x : 280, y : 100});
            c.path.push({x : 200, y : 320});
            c.next = queues[1];
            c.state.output = "F";
            c.position = c.path[0];
            Memo.create(queues[0].connections, c);
            c = new Connection({x : 280, y : 400});
            c.path.push({x : 620, y : 400});
            c.next = queues[2];
            c.state.output = "A";
            c.position = c.path[0];
            Memo.create(queues[1].connections, c);
            MediaDOM.procedureName.value = "Xdebug";
            MediaDOM.createProcedure(event);
            queues.length = 0;
            Memo.create(queues, new Procedure({ x: 200, y: 400 }, "Xdebug"));
            MediaDOM.procedureName.value = "";
        }
    }
}
@keyframes blinker {
    50% {
        opacity: 0;
    }
}

@keyframes displaySettings {
    60% {
        margin: 10px 0;
    }
    100% {
        opacity: .8;
        margin: 10px 0;
    }
}

html,
body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    cursor: crosshair;
}

body * {
    user-select: none;
    outline: none;
}

button,
svg,
#state div {
    cursor: move;
}

::-webkit-scrollbar {
    height: 4px;
}

::-webkit-scrollbar-track {
    background: #3a3a3a;
}

::-webkit-scrollbar-thumb {
    background: #ccc;
}

ul,
li {
    margin: 0;
    padding: 0;
}

#memory,
#builder {
    width: 100%;
    height: 6%;
    background-color: #3a3a3a;
    display: inline-flex;
}

.memory-container {
    display: flex;
    flex-direction: column-reverse;
    padding: 0 10px;
    background-color: #222;
}

.memory-container * {
    width: 100%;
    margin: auto;
    text-align: center;
}

.memory-container>#memory_index {
    font-size: 3.8vh;
    color: #0bf;
}

.memory-container>#memory_size {
    font-size: 1.4vh;
    color: #fff;
}

#cells {
    width: 100%;
    display: flex;
    gap: 4px;
    flex-wrap: nowrap;
    list-style-type: none;
    overflow: auto hidden;
    border: 4px #000 solid;
}

#cells>li {
    min-width: 3vw;
    line-height: 4vh;
    margin: auto 0;
    background-color: #ddd;
    border-radius: 0.5em;
    text-align: center;
    font-size: 1.5em;
}

#cells li.pointer {
    background-image: radial-gradient(#fff, #24f);
}

#media {
    width: 300px;
    height: 100% - 2px;
    display: flex;
    background: #222;
    gap: 8px;
    padding: 0 8px;
}

#media>#play_pause {
    height: 50%;
    margin: auto 0;
    padding: 0;
    background: transparent;
    box-sizing: border-box;
    border-color: transparent transparent transparent #6f9;
    transition: 200ms all ease;
    border-style: solid;
    border-width: 15px 0 15px 25px;
}

#media>#play_pause.pause {
    border-color: transparent transparent transparent #f88;
    border-style: double;
    border-width: 0 0 0 25px;
}

#media #reset {
    width: 25px;
    height: 50%;
    margin: auto 0;
    background-color: transparent;
    border: 3px #f8f solid;
    transition: 200ms all ease;
}

#media #reset:hover {
    border-width: 5px;
}

#media #reset:active {
    border: 6px #faf groove;
    transition: none;
}

#media>#undo,
#media>#redo {
    height: 20px;
    margin: auto 0;
    fill: #444;
    transition: 300ms;
    cursor: crosshair;
}

#media>#undo.available,
#media>#redo.available {
    fill: #aaa;
    cursor: move;
}

#media>#undo.available:hover,
#media>#redo.available:hover {
    fill: #fff;
}

#media>#undo.activated,
#media>#redo.activated,
#media>#undo.activated:hover,
#media>#redo.activated:hover {
    fill: #fa4;
    transition: all;
}

.procedure {
    width: 120px;
    height: 100%;
    text-align: center;
}

#procedure_name {
    text-align: center;
    font-size: 2vh;
    border: none;
    border-radius: 4px;
    width: 100%;
}

#procedure_save {
    width: 100%;
    font-size: 2vh;
    background-color: #6aa;
    font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
}

#procedure_delete {
    width: 100%;
    font-size: 2vh;
    background-color: #b54;
    font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
}

#state {
    background-color: #2a2a2f;
    display: inline-flex;
    gap: 4px;
    padding: 0 4px;
}

#state>div {
    width: 30px;
    height: 80%;
    margin: auto;
    display: flex;
    flex: 1;
    border: 3px #ccc solid;
    color: #ddd;
    border-radius: 6px;
    transition: 400ms;
}

#state>div:hover {
    background-color: #999;
}

#state>div:active {
    background-color: #555;
    transition: 0ms;
}

#state>div.set-state {
    background-color: #999;
}

#state>div.set-state * {
    animation: blinker 350ms step-end infinite;
}

#state>div>p {
    margin: auto;
    font-size: 25px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

#entities {
    width: 100%;
    height: 100%;
    display: flex;
    background-color: #444;
    border-radius: 100px;
    padding: 0 20px;
    overflow-x: auto;
}

#entities>button {
    background-color: #222;
    color: #ddd;
    border: none;
    border-radius: 12px;
    transition: 200ms;
    margin: 4px;
    padding: 0 10px;
    font-size: 20px;
    font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
}

#entities>button:hover,
#entities>button:target {
    background-color: #ddd;
    color: #222;
    padding: 0 16px;
}

#settings_button {
    width: 52px;
    margin: auto 8px;
    border-radius: 100px;
    background-color: #aaa;
    fill: #333;
    transition: 300ms;
}

#settings_button:hover {
    background-color: #fff;
    transform: rotate(50deg);
}

#settings_button:active {
    background-color: #aaa;
    transition: all;
}

#settings {
    position: absolute;
    width: 50vw;
    height: 50vh;
    background-color: #fff;
    border-radius: 12px;
    opacity: 0;
    left: 25%;
    margin: 0px 0;
    padding: 0 10px;
}

#settings.display {
    animation: displaySettings .5s ease-in;
    animation-fill-mode: forwards;
    cursor: default;
}

#settings h1 {
    text-align: center;
}

#settings h2 {
    font-family: monospace;
    color: #333;
}